# -*- coding: utf-8 -*-
# Rectangle plein : couverture portée sur u = y*z (x supprimé)
# df: colonnes ['entite','label','controle'] avec certaines paires éventuellement manquantes
# Nécessite: pip install pulp pandas

import pandas as pd
import pulp as pl

def solve_full_rectangle(
    df: pd.DataFrame,
    tau: float = 0.80,
    preselected_entities=None,
    preselected_labels=None,
    objective: str = "product",  # "product" ou "entities_labels"
    time_limit: int = 300,
    frac_gap: float | None = None,
    verbose: bool = True,
):
    df = df.copy()
    df['controle'] = df['controle'].astype(float)

    E = sorted(df['entite'].unique())
    L = sorted(df['label'].unique())

    # Construire c_{e,l} sur tout E×L, 0 si paire absente
    c = {(e,l): 0.0 for e in E for l in L}
    for r in df.itertuples(index=False):
        c[(r.entite, r.label)] = float(r.controle)

    Ctot = sum(c.values())
    if Ctot <= 0:
        raise ValueError("Somme des contrôles nulle. Rien à couvrir.")

    E_star = set(preselected_entities or [])
    L_star = set(preselected_labels or [])

    m = pl.LpProblem("FullRectangle_Coverage", pl.LpMinimize)

    # Variables
    y = pl.LpVariable.dicts("y", E, 0, 1, cat="Binary")
    z = pl.LpVariable.dicts("z", L, 0, 1, cat="Binary")
    u = {(e,l): pl.LpVariable(f"u_{e}__{l}", 0, 1, cat="Binary") for e in E for l in L}

    # Couverture sur u
    m += pl.lpSum(c[(e,l)] * u[(e,l)] for e in E for l in L) >= tau * Ctot, "couverture"

    # Linéarisation u = y * z
    for e in E:
        for l in L:
            m += u[(e,l)] <= y[e], f"u_le_y__{e}__{l}"
            m += u[(e,l)] <= z[l], f"u_le_z__{e}__{l}"
            m += u[(e,l)] >= y[e] + z[l] - 1, f"u_ge_ypluszminus1__{e}__{l}"

    # Pré-sélections
    for e in E_star:
        m += y[e] == 1, f"preselect_entity__{e}"
    for l in L_star:
        m += z[l] == 1, f"preselect_label__{l}"

    # Objectif
    if objective == "product":
        # Minimiser |E_sel|×|L_sel| (via sum u)
        m += pl.lpSum(u[(e,l)] for e in E for l in L), "min_cartesian_cardinality"
    elif objective == "entities_labels":
        m += pl.lpSum(y[e] for e in E) + pl.lpSum(z[l] for l in L), "min_entities_plus_labels"
    else:
        raise ValueError("objective doit être 'product' ou 'entities_labels'")

    solver = pl.PULP_CBC_CMD(
        msg=bool(verbose),
        timeLimit=int(time_limit) if time_limit else None,
        fracGap=frac_gap if frac_gap is not None else None,
    )
    status_code = m.solve(solver)
    status = pl.LpStatus.get(status_code, str(status_code))

    def is_one(v, thr=0.5): 
        try: return float(pl.value(v)) > thr
        except: return False

    y_sel = [e for e in E if is_one(y[e])]
    z_sel = [l for l in L if is_one(z[l])]
    u_sel = [(e,l) for e in E for l in L if is_one(u[(e,l)])]

    covered = sum(c[(e,l)] for (e,l) in u_sel)
    coverage = covered / Ctot
    obj_val = pl.value(m.objective)

    if verbose:
        print("Status :", status)
        if objective == "product":
            print(f"Objectif (|E_sel|×|L_sel| via sum u) : {obj_val:.0f}")
        else:
            print(f"Objectif (|E_sel| + |L_sel|) : {obj_val:.0f}")
        print(f"|E_sel|={len(y_sel)}, |L_sel|={len(z_sel)}, produit={len(y_sel)*len(z_sel)}, somme_u={len(u_sel)}")
        print(f"Couverture : {coverage*100:.2f}%  ({covered} / {Ctot})")

    return {
        "status": status,
        "objective_value": obj_val,
        "E_selected": y_sel,
        "L_selected": z_sel,
        "pairs_active_rectangle": u_sel,
        "cartesian_product_size": len(y_sel) * len(z_sel),
        "sum_u": len(u_sel),
        "coverage_ratio": coverage,
        "covered_controls": covered,
        "total_controls": Ctot,
    }
